
name: NovaBridge Android Cloud Build v17 NEXT

on:
  workflow_dispatch:
  repository_dispatch:
    types: [novabridge_android_build_v17_next]

jobs:
  android-build-next:
    runs-on: ubuntu-latest

    env:
      BUILD_ID: ${{ github.event.client_payload.build_id }}
      ZIP_URL: ${{ github.event.client_payload.zip_url }}
      CALLBACK_URL: ${{ github.event.client_payload.callback_url }}

      # R2 (Cloudflare) credentials (store these in GitHub Secrets)
      R2_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
      R2_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
      R2_BUCKET: ${{ secrets.R2_BUCKET }}
      R2_ACCOUNT_ID: ${{ secrets.R2_ACCOUNT_ID }}

      # Worker callback auth
      CALLBACK_TOKEN: ${{ secrets.CALLBACK_TOKEN }}

      # Optional: if you want the workflow to craft a public URL using your Worker domain
      # (set this secret to "https://novabridge-build-worker-next.novabridge.workers.dev")
      WORKER_PUBLIC_BASE: ${{ secrets.WORKER_PUBLIC_BASE }}

    steps:
      - name: üß© Checkout repo
        uses: actions/checkout@v4

      - name: ‚òï Setup Java 17
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "17"

      - name: üß∞ Install tools
        run: |
          sudo apt-get update
          sudo apt-get install -y unzip jq
          python -m pip install --upgrade pip
          pip install awscli

      - name: üì• Download build ZIP
        run: |
          set -e
          echo "BUILD_ID=${BUILD_ID}"
          echo "ZIP_URL=${ZIP_URL}"
          mkdir -p work
          cd work
          curl -L --fail -o project.zip "${ZIP_URL}"
          ls -lah project.zip

      - name: üß± Extract build ZIP
        run: |
          set -e
          cd work
          rm -rf extracted
          mkdir -p extracted
          unzip -q project.zip -d extracted
          echo "Extracted top-level:"
          ls -lah extracted

      - name: üîé Locate Android project root
        id: locate
        run: |
          set -e
          cd work/extracted

          # Find a folder that contains a Gradle Android root:
          # settings.gradle(.kts) OR gradlew
          ROOT="$(find . -maxdepth 4 -type f \( -name "settings.gradle" -o -name "settings.gradle.kts" -o -name "gradlew" \) -print | head -n 1 | xargs -I{} dirname {})"

          if [ -z "${ROOT}" ]; then
            echo "‚ùå Could not locate Android root (settings.gradle/gradlew not found)."
            echo "Listing extracted tree (depth 4):"
            find . -maxdepth 4 -type d -print
            exit 1
          fi

          # Normalize to absolute path
          ANDROID_ROOT="$(cd "${ROOT}" && pwd)"
          echo "‚úÖ ANDROID_ROOT=${ANDROID_ROOT}"
          echo "ANDROID_ROOT=${ANDROID_ROOT}" >> $GITHUB_OUTPUT

      - name: üîß Ensure gradlew runnable
        run: |
          set -e
          ANDROID_ROOT="${{ steps.locate.outputs.ANDROID_ROOT }}"
          cd "${ANDROID_ROOT}"

          if [ -f "./gradlew" ]; then
            chmod +x ./gradlew || true
            echo "‚úÖ gradlew present"
          else
            echo "‚ùå gradlew missing at Android root"
            ls -lah
            exit 1
          fi

          if [ ! -f "./gradle/wrapper/gradle-wrapper.jar" ]; then
            echo "‚ùå gradle-wrapper.jar missing (ZIP should include it)."
            echo "Found wrapper folder:"
            ls -lah ./gradle/wrapper || true
            exit 1
          fi

      - name: üß© NEXT Plugin deps auto-wire (biometric + location)
        run: |
          set -e
          ANDROID_ROOT="${{ steps.locate.outputs.ANDROID_ROOT }}"
          cd "${ANDROID_ROOT}"

          # Locate app module build.gradle (Groovy)
          APP_GRADLE=""
          if [ -f "app/build.gradle" ]; then
            APP_GRADLE="app/build.gradle"
          elif [ -f "build/app/build.gradle" ]; then
            APP_GRADLE="build/app/build.gradle"
          fi

          if [ -z "${APP_GRADLE}" ]; then
            echo "‚ùå Could not find app/build.gradle (Groovy)."
            echo "Files:"
            find . -maxdepth 3 -type f -name "build.gradle" -print
            exit 1
          fi

          echo "‚úÖ Using APP_GRADLE=${APP_GRADLE}"

          # Detect plugin sources anywhere under app/src/.../plugins
          HAS_LOCATION="$(find . -type f -name "LocationPlugin.java" | wc -l | tr -d ' ')"
          HAS_BIOMETRIC="$(find . -type f -name "BiometricPlugin.java" | wc -l | tr -d ' ')"

          echo "HAS_LOCATION=${HAS_LOCATION}"
          echo "HAS_BIOMETRIC=${HAS_BIOMETRIC}"

          if [ "${HAS_LOCATION}" -eq 0 ] && [ "${HAS_BIOMETRIC}" -eq 0 ]; then
            echo "No plugin Java sources detected ‚Äî skipping dependency patch."
            exit 0
          fi

          # Ensure repositories include google()
          if ! grep -qE "^[[:space:]]*google\\(\\)" "${APP_GRADLE}"; then
            echo "‚ö†Ô∏è google() repo not found in ${APP_GRADLE} ‚Äî attempting safe insert into repositories{}"
            # insert google() inside first repositories { ... } block
            perl -0777 -i -pe 's/repositories\s*\{\s*/repositories {\n        google()\n/ if !/repositories\s*\{[^}]*google\(\)/s' "${APP_GRADLE}"
          fi

          # Ensure dependencies block exists
          if ! grep -qE "dependencies\s*\{" "${APP_GRADLE}"; then
            echo "‚ùå dependencies{} block missing in ${APP_GRADLE}"
            exit 1
          fi

          # Add biometric dependency if needed
          if [ "${HAS_BIOMETRIC}" -gt 0 ]; then
            if ! grep -qE "androidx\.biometric:biometric" "${APP_GRADLE}"; then
              echo "‚ûï Adding androidx.biometric dependency"
              perl -0777 -i -pe 's/dependencies\s*\{\s*/dependencies {\n    implementation "androidx.biometric:biometric:1.1.0"\n/ if !/androidx\.biometric:biometric/s' "${APP_GRADLE}"
            else
              echo "‚úÖ androidx.biometric already present"
            fi
          fi

          # Add play-services-location dependency if needed
          if [ "${HAS_LOCATION}" -gt 0 ]; then
            if ! grep -qE "com\.google\.android\.gms:play-services-location" "${APP_GRADLE}"; then
              echo "‚ûï Adding play-services-location dependency"
              perl -0777 -i -pe 's/dependencies\s*\{\s*/dependencies {\n    implementation "com.google.android.gms:play-services-location:21.3.0"\n/ if !/play-services-location/s' "${APP_GRADLE}"
            else
              echo "‚úÖ play-services-location already present"
            fi
          fi

          echo "---- APP_GRADLE (patched preview) ----"
          sed -n '1,200p' "${APP_GRADLE}" | head -n 200

      - name: üèóÔ∏è Build APK (Release ‚Üí Debug fallback)
        id: build
        run: |
          set -e
          ANDROID_ROOT="${{ steps.locate.outputs.ANDROID_ROOT }}"
          cd "${ANDROID_ROOT}"

          echo "Running: ./gradlew --no-daemon assembleRelease"
          if ./gradlew --no-daemon assembleRelease; then
            echo "BUILD_VARIANT=release" >> $GITHUB_OUTPUT
          else
            echo "Release failed ‚Äî fallback to Debug"
            ./gradlew --no-daemon assembleDebug
            echo "BUILD_VARIANT=debug" >> $GITHUB_OUTPUT
          fi

          echo "Finding APK‚Ä¶"
          APK_PATH="$(find . -type f -name "*.apk" | grep -E "/outputs/apk/" | head -n 1)"

          if [ -z "${APK_PATH}" ]; then
            echo "‚ùå APK not found under outputs/apk"
            find . -maxdepth 6 -type f -name "*.apk" -print || true
            exit 1
          fi

          echo "‚úÖ APK_PATH=${APK_PATH}"
          echo "APK_PATH=${APK_PATH}" >> $GITHUB_OUTPUT

      - name: ‚òÅÔ∏è Upload APK to R2
        id: upload
        run: |
          set -e
          ANDROID_ROOT="${{ steps.locate.outputs.ANDROID_ROOT }}"
          cd "${ANDROID_ROOT}"

          APK_PATH="${{ steps.build.outputs.APK_PATH }}"
          DEST_KEY="artifact-android-next/${BUILD_ID}.apk"

          export AWS_ACCESS_KEY_ID="${R2_ACCESS_KEY_ID}"
          export AWS_SECRET_ACCESS_KEY="${R2_SECRET_ACCESS_KEY}"
          export AWS_DEFAULT_REGION="auto"

          ENDPOINT="https://${R2_ACCOUNT_ID}.r2.cloudflarestorage.com"

          echo "Uploading to s3://${R2_BUCKET}/${DEST_KEY}"
          aws s3 cp "${APK_PATH}" "s3://${R2_BUCKET}/${DEST_KEY}" --endpoint-url "${ENDPOINT}"

          # Prefer Worker-based public URL if provided; otherwise return a key-only URL.
          if [ -n "${WORKER_PUBLIC_BASE}" ]; then
            ARTIFACT_URL="${WORKER_PUBLIC_BASE}/artifact/${DEST_KEY}"
          else
            ARTIFACT_URL="r2://${R2_BUCKET}/${DEST_KEY}"
          fi

          echo "‚úÖ ARTIFACT_URL=${ARTIFACT_URL}"
          echo "ARTIFACT_URL=${ARTIFACT_URL}" >> $GITHUB_OUTPUT
          echo "DEST_KEY=${DEST_KEY}" >> $GITHUB_OUTPUT

      - name: üì° Callback Worker (NEXT)
        run: |
          set -e
          ARTIFACT_URL="${{ steps.upload.outputs.ARTIFACT_URL }}"
          DEST_KEY="${{ steps.upload.outputs.DEST_KEY }}"

          echo "Calling callback: ${CALLBACK_URL}"
          echo "artifact_url=${ARTIFACT_URL}"
          echo "dest_key=${DEST_KEY}"

          curl -sS -X POST "${CALLBACK_URL}" \
            -H "Content-Type: application/json" \
            -H "x-novabridge-token: ${CALLBACK_TOKEN}" \
            -d "$(jq -n \
              --arg build_id "${BUILD_ID}" \
              --arg status "success" \
              --arg artifact_url "${ARTIFACT_URL}" \
              --arg dest_key "${DEST_KEY}" \
              '{build_id:$build_id,status:$status,artifact_url:$artifact_url,dest_key:$dest_key}')"

      - name: ‚ùå On failure callback (NEXT)
        if: failure()
        run: |
          set -e
          echo "Build failed ‚Äî notifying worker"
          curl -sS -X POST "${CALLBACK_URL}" \
            -H "Content-Type: application/json" \
            -H "x-novabridge-token: ${CALLBACK_TOKEN}" \
            -d "$(jq -n \
              --arg build_id "${BUILD_ID}" \
              --arg status "failed" \
              --arg message "GitHub Actions build failed (see logs)" \
              '{build_id:$build_id,status:$status,message:$message}')"
