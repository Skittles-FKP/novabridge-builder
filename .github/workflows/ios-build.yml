# .github/workflows/ios-build.yml
name: NovaBridge iOS Cloud Build v1.1

on:
  workflow_dispatch:
    inputs:
      build_id:
        description: "Build ID (from iOS Worker)"
        required: false
      zip_url:
        description: "ZIP URL (from iOS Worker)"
        required: false
      callback_url:
        description: "Callback URL (from iOS Worker)"
        required: false

  repository_dispatch:
    types: [novabridge_ios_build_v1] # MUST match IOS_DISPATCH_EVENT in your iOS Worker

jobs:
  ios-build:
    runs-on: macos-latest

    env:
      BUILD_ID: ${{ github.event.client_payload.build_id || inputs.build_id }}
      ZIP_URL: ${{ github.event.client_payload.zip_url || inputs.zip_url }}
      CALLBACK_URL: ${{ github.event.client_payload.callback_url || inputs.callback_url }}

      # âœ… REQUIRED: must exist as a GitHub Actions SECRET (NOT repo variable)
      CALLBACK_TOKEN: ${{ secrets.CALLBACK_TOKEN }}

      # R2 (optional if you upload to Worker directly instead)
      R2_ACCOUNT_ID: ${{ secrets.R2_ACCOUNT_ID }}
      R2_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
      R2_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
      R2_BUCKET: ${{ secrets.R2_BUCKET }}

    steps:
      - name: ðŸ§ª Print incoming payload
        shell: bash
        run: |
          set -e
          echo "âž¡ BUILD_ID=$BUILD_ID"
          echo "âž¡ ZIP_URL=$ZIP_URL"
          echo "âž¡ CALLBACK_URL=$CALLBACK_URL"
          if [ -z "$BUILD_ID" ]; then echo "âŒ BUILD_ID missing"; exit 1; fi
          if [ -z "$ZIP_URL" ]; then echo "âŒ ZIP_URL missing"; exit 1; fi
          if [ -z "$CALLBACK_URL" ]; then echo "âŒ CALLBACK_URL missing"; exit 1; fi
          if [ -z "$CALLBACK_TOKEN" ]; then echo "âŒ CALLBACK_TOKEN missing"; exit 1; fi
          echo "âž¡ CALLBACK_TOKEN_LENGTH=${#CALLBACK_TOKEN}"

      - name: ðŸ”” Callback helper (function)
        shell: bash
        run: |
          cat > cb.sh <<'EOF'
          cb() {
            local payload="$1"
            echo "âž¡ cb payload: $payload"
            curl -sS -D - -o /tmp/cb.out \
              -H "Content-Type: application/json" \
              -H "x-novabridge-token: ${CALLBACK_TOKEN}" \
              -X POST "${CALLBACK_URL}" \
              --data "$payload" || true
            echo "âž¡ cb response:"
            cat /tmp/cb.out || true
            echo
          }
          EOF
          chmod +x cb.sh

      - name: ðŸš€ Step 3 â€” Downloading Project
        shell: bash
        run: |
          set -e
          source ./cb.sh
          cb "{\"build_id\":\"$BUILD_ID\",\"step\":3,\"step_state\":\"active\",\"log\":\"iOS: ðŸ“¥ Downloading iOS project files\"}"

          curl -sS -L "$ZIP_URL" -o ios.zip

          # Hard check: must be a zip
          if ! unzip -t ios.zip >/dev/null 2>&1; then
            echo "âŒ Downloaded file is not a valid zip. Showing first bytes:"
            head -c 200 ios.zip || true
            cb "{\"build_id\":\"$BUILD_ID\",\"step\":3,\"step_state\":\"failed\",\"status\":\"failed\",\"error\":\"Downloaded ZIP is invalid (not a zip).\"}"
            exit 9
          fi

          unzip -q ios.zip -d .
          cb "{\"build_id\":\"$BUILD_ID\",\"step\":3,\"step_state\":\"done\",\"log\":\"iOS: âœ… Project files downloaded\"}"

      - name: ðŸ§± Step 4 â€” Generate Xcode project (XcodeGen)
        shell: bash
        run: |
          set -e
          source ./cb.sh
          cb "{\"build_id\":\"$BUILD_ID\",\"step\":4,\"step_state\":\"active\",\"log\":\"iOS: ðŸ§± Generating Xcode project\"}"

          # Find a project.yml produced by the Worker
          PROJECT_YML="$(find ios -name project.yml | head -n 1 || true)"
          if [ -z "$PROJECT_YML" ]; then
            cb "{\"build_id\":\"$BUILD_ID\",\"step\":4,\"step_state\":\"failed\",\"status\":\"failed\",\"error\":\"project.yml not found in zip\"}"
            echo "âŒ project.yml not found"
            exit 1
          fi

          IOS_DIR="$(dirname "$PROJECT_YML")"
          echo "ðŸ“‚ IOS_DIR=$IOS_DIR"

          # Install xcodegen (fast)
          brew update >/dev/null 2>&1 || true
          brew install xcodegen >/dev/null 2>&1 || true

          cd "$IOS_DIR"
          xcodegen generate

          # Verify xcodeproj exists
          XCODEPROJ="$(find . -maxdepth 1 -name "*.xcodeproj" | head -n 1 || true)"
          if [ -z "$XCODEPROJ" ]; then
            cb "{\"build_id\":\"$BUILD_ID\",\"step\":4,\"step_state\":\"failed\",\"status\":\"failed\",\"error\":\"Xcode project not generated\"}"
            echo "âŒ No .xcodeproj generated"
            exit 1
          fi

          cb "{\"build_id\":\"$BUILD_ID\",\"step\":4,\"step_state\":\"done\",\"log\":\"iOS: âœ… Xcode project generated\"}"

      - name: ðŸ“± Step 5 â€” Queued on macOS runner
        shell: bash
        run: |
          set -e
          source ./cb.sh
          cb "{\"build_id\":\"$BUILD_ID\",\"step\":5,\"step_state\":\"active\",\"log\":\"iOS: ðŸ“± Queued on macOS runner\"}"
          # nothing to do; step exists to reflect UI state
          cb "{\"build_id\":\"$BUILD_ID\",\"step\":5,\"step_state\":\"done\",\"log\":\"iOS: âœ… Runner started\"}"

      - name: ðŸŽ¨ Ensure AppIcon is 1024 + generate full iconset sizes
        shell: bash
        run: |
          set -e
          source ./cb.sh

          # We run this inside the generated iOS dir
          PROJECT_YML="$(find ios -name project.yml | head -n 1)"
          IOS_DIR="$(dirname "$PROJECT_YML")"
          cd "$IOS_DIR"

          ICON_DIR="App/Assets.xcassets/AppIcon.appiconset"
          ICON_1024="$ICON_DIR/AppIcon-1024.png"

          if [ ! -f "$ICON_1024" ]; then
            cb "{\"build_id\":\"$BUILD_ID\",\"step\":6,\"step_state\":\"failed\",\"status\":\"failed\",\"error\":\"Missing AppIcon-1024.png\"}"
            echo "âŒ Missing $ICON_1024"
            exit 1
          fi

          echo "ðŸŽ¨ Using source icon: $ICON_1024"

          # Resize to 1024 exactly (safe even if already 1024)
          sips -Z 1024 "$ICON_1024" --out "$ICON_1024" >/dev/null

          # Create common required sizes (simple set; enough for AppIcon)
          # (Xcode will also accept fewer when ios-marketing is correct, but we generate more for safety)
          declare -a SIZES=("20@2" "20@3" "29@2" "29@3" "40@2" "40@3" "60@2" "60@3" "76@2" "83.5@2")
          for item in "${SIZES[@]}"; do
            base="${item%@*}"
            scale="${item#*@}"
            # handle 83.5
            python3 - <<PY
import math
base=float("${base}")
scale=int("${scale}")
px=int(round(base*scale))
print(px)
PY
            px="$(python3 - <<PY
import math
base=float("${base}")
scale=int("${scale}")
print(int(round(base*scale)))
PY
)"
            out="$ICON_DIR/AppIcon-${base}@${scale}x.png"
            sips -z "$px" "$px" "$ICON_1024" --out "$out" >/dev/null
          done

          # Generate Contents.json (full)
          cat > "$ICON_DIR/Contents.json" <<'JSON'
{
  "images" : [
    { "idiom" : "universal", "size" : "20x20", "scale" : "2x", "filename" : "AppIcon-20@2x.png" },
    { "idiom" : "universal", "size" : "20x20", "scale" : "3x", "filename" : "AppIcon-20@3x.png" },
    { "idiom" : "universal", "size" : "29x29", "scale" : "2x", "filename" : "AppIcon-29@2x.png" },
    { "idiom" : "universal", "size" : "29x29", "scale" : "3x", "filename" : "AppIcon-29@3x.png" },
    { "idiom" : "universal", "size" : "40x40", "scale" : "2x", "filename" : "AppIcon-40@2x.png" },
    { "idiom" : "universal", "size" : "40x40", "scale" : "3x", "filename" : "AppIcon-40@3x.png" },
    { "idiom" : "universal", "size" : "60x60", "scale" : "2x", "filename" : "AppIcon-60@2x.png" },
    { "idiom" : "universal", "size" : "60x60", "scale" : "3x", "filename" : "AppIcon-60@3x.png" },
    { "idiom" : "universal", "size" : "76x76", "scale" : "2x", "filename" : "AppIcon-76@2x.png" },
    { "idiom" : "universal", "size" : "83.5x83.5", "scale" : "2x", "filename" : "AppIcon-83.5@2x.png" },
    { "idiom" : "ios-marketing", "size" : "1024x1024", "scale" : "1x", "filename" : "AppIcon-1024.png" }
  ],
  "info" : { "version" : 1, "author" : "xcode" }
}
JSON

      - name: ðŸ”¨ Step 6 â€” Build iOS app with Xcode (unsigned)
        shell: bash
        run: |
          set -e
          source ./cb.sh
          cb "{\"build_id\":\"$BUILD_ID\",\"step\":6,\"step_state\":\"active\",\"log\":\"iOS: ðŸ”¨ Building iOS app with Xcode\"}"

          PROJECT_YML="$(find ios -name project.yml | head -n 1)"
          IOS_DIR="$(dirname "$PROJECT_YML")"
          cd "$IOS_DIR"

          XCODEPROJ="$(find . -maxdepth 1 -name '*.xcodeproj' | head -n 1)"
          echo "ðŸ“¦ PROJECT=$XCODEPROJ"

          # List schemes
          echo "ðŸ§¾ Available schemes:"
          xcodebuild -list -project "$XCODEPROJ" | sed 's/^/  /'

          # Extract scheme name EXACTLY (avoid whitespace issue)
          SCHEME="$(xcodebuild -list -project "$XCODEPROJ" | awk '/Schemes:/{flag=1;next}/^$/{flag=0}flag{print;exit}' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
          if [ -z "$SCHEME" ]; then
            cb "{\"build_id\":\"$BUILD_ID\",\"step\":6,\"step_state\":\"failed\",\"status\":\"failed\",\"error\":\"No scheme found\"}"
            echo "âŒ No scheme found"
            exit 1
          fi
          echo "ðŸŽ¯ Building scheme: $SCHEME"

          # Build (unsigned; produces .app)
          set +e
          xcodebuild -project "$XCODEPROJ" -scheme "$SCHEME" -configuration Release -destination generic/platform=iOS CODE_SIGNING_ALLOWED=NO build | tee xcodebuild.log
          EXIT_CODE=${PIPESTATUS[0]}
          set -e

          if [ "$EXIT_CODE" -ne 0 ]; then
            cb "{\"build_id\":\"$BUILD_ID\",\"step\":6,\"step_state\":\"failed\",\"status\":\"failed\",\"error\":\"xcodebuild failed (exit $EXIT_CODE)\"}"
            echo "âŒ xcodebuild failed"
            exit "$EXIT_CODE"
          fi

          cb "{\"build_id\":\"$BUILD_ID\",\"step\":6,\"step_state\":\"done\",\"log\":\"iOS: âœ… Build completed\"}"

      - name: ðŸ“¦ Step 7 â€” Package iOS build artifacts
        shell: bash
        run: |
          set -e
          source ./cb.sh
          cb "{\"build_id\":\"$BUILD_ID\",\"step\":7,\"step_state\":\"active\",\"log\":\"iOS: ðŸ“¦ Packaging iOS build artifacts\"}"

          PROJECT_YML="$(find ios -name project.yml | head -n 1)"
          IOS_DIR="$(dirname "$PROJECT_YML")"
          cd "$IOS_DIR"

          # Find built .app
          APP_PATH="$(find ~/Library/Developer/Xcode/DerivedData -type d -name '*.app' | grep -E '/Build/Products/Release-iphoneos/' | head -n 1 || true)"
          if [ -z "$APP_PATH" ]; then
            cb "{\"build_id\":\"$BUILD_ID\",\"step\":7,\"step_state\":\"failed\",\"status\":\"failed\",\"error\":\".app not found in DerivedData\"}"
            echo "âŒ .app not found"
            exit 1
          fi

          echo "ðŸ“¦ Found app: $APP_PATH"

          mkdir -p out
          cp -R "$APP_PATH" out/App.app
          cp -f xcodebuild.log out/xcodebuild.log || true

          # Zip artifact
          ARTIFACT_KEY="ios/artifacts/${BUILD_ID}.zip"
          (cd out && zip -qr "../ios-build-${BUILD_ID}.zip" .)

          cb "{\"build_id\":\"$BUILD_ID\",\"step\":7,\"step_state\":\"done\",\"log\":\"iOS: âœ… Artifacts packaged\"}"

          echo "ARTIFACT_KEY=$ARTIFACT_KEY" >> $GITHUB_ENV
          echo "ARTIFACT_ZIP=ios-build-${BUILD_ID}.zip" >> $GITHUB_ENV

      - name: â˜ï¸ Upload artifact to Cloudflare R2
        shell: bash
        run: |
          set -e
          # Use AWS CLI against R2
          brew install awscli >/dev/null 2>&1 || true

          aws configure set aws_access_key_id "$R2_ACCESS_KEY_ID"
          aws configure set aws_secret_access_key "$R2_SECRET_ACCESS_KEY"
          aws configure set default.region auto

          ENDPOINT="https://${R2_ACCOUNT_ID}.r2.cloudflarestorage.com"
          aws s3 cp "$ARTIFACT_ZIP" "s3://${R2_BUCKET}/${ARTIFACT_KEY}" --endpoint-url "$ENDPOINT"

      - name: âœ… Step 8 â€” Notify Worker (success + artifact_key)
        shell: bash
        run: |
          set -e
          source ./cb.sh

          cb "{\"build_id\":\"$BUILD_ID\",\"status\":\"success\",\"step\":8,\"step_state\":\"done\",\"artifact_key\":\"$ARTIFACT_KEY\",\"log\":\"iOS: âœ… Build complete\"}"

      - name: ðŸ“Ž Upload logs as GitHub artifact (debug)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: xcodebuild-log-${{ env.BUILD_ID }}
          path: |
            **/xcodebuild.log
            **/ios-build-${{ env.BUILD_ID }}.zip

      - name: âŒ Notify Worker (failure)
        if: failure()
        shell: bash
        run: |
          set +e
          source ./cb.sh 2>/dev/null || true
          cb "{\"build_id\":\"$BUILD_ID\",\"status\":\"failed\",\"step\":6,\"step_state\":\"failed\",\"error\":\"GitHub Actions job failed\"}"
          exit 1
