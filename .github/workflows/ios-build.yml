name: NovaBridge iOS Cloud Build v1.1

on:
  workflow_dispatch:
  repository_dispatch:
    types: [novabridge_ios_build_v1]

jobs:
  ios-build:
    runs-on: macos-latest

    env:
      BUILD_ID: ${{ github.event.client_payload.build_id }}
      ZIP_URL: ${{ github.event.client_payload.zip_url }}
      CALLBACK_URL: ${{ github.event.client_payload.callback_url }}

      # IMPORTANT: this must be a GitHub *SECRET* (Settings ‚Üí Secrets and variables ‚Üí Actions)
      CALLBACK_TOKEN: ${{ secrets.CALLBACK_TOKEN }}

    steps:
      - name: üß™ Validate payload + secrets
        shell: bash
        run: |
          set -euo pipefail
          echo "‚û° BUILD_ID=$BUILD_ID"
          echo "‚û° ZIP_URL=$ZIP_URL"
          echo "‚û° CALLBACK_URL=$CALLBACK_URL"
          if [ -z "${BUILD_ID:-}" ]; then echo "‚ùå BUILD_ID missing"; exit 1; fi
          if [ -z "${ZIP_URL:-}" ]; then echo "‚ùå ZIP_URL missing"; exit 1; fi
          if [ -z "${CALLBACK_URL:-}" ]; then echo "‚ùå CALLBACK_URL missing"; exit 1; fi
          if [ -z "${CALLBACK_TOKEN:-}" ]; then echo "‚ùå CALLBACK_TOKEN missing (GitHub Actions Secret)"; exit 1; fi
          echo "‚û° CALLBACK_TOKEN_LENGTH=${#CALLBACK_TOKEN}"

      - name: üì£ Callback helper (live steps)
        shell: bash
        run: |
          set -euo pipefail
          cat > cb.sh <<'EOF'
          cb() {
            local payload="$1"
            echo "‚û° cb payload: $payload"
            # --fail-with-body makes 401 show and fail fast
            curl --fail-with-body -sS -X POST "$CALLBACK_URL" \
              -H "Content-Type: application/json" \
              -H "x-novabridge-token: $CALLBACK_TOKEN" \
              --data "$payload"
            echo ""
          }
          EOF
          chmod +x cb.sh

      - name: üì• Download iOS project ZIP (Step 3 active)
        shell: bash
        run: |
          set -euo pipefail
          source ./cb.sh
          cb "{\"build_id\":\"$BUILD_ID\",\"step\":3,\"step_state\":\"active\",\"log\":\"iOS: üì• Downloading iOS project files\"}"
          curl -L --fail-with-body -o ios.zip "$ZIP_URL"
          mkdir -p work
          unzip -q ios.zip -d work
          echo "üìÅ Listing work directory:"
          find work -maxdepth 4 -type f -print

      - name: üîß Install XcodeGen
        shell: bash
        run: |
          set -euo pipefail
          if ! command -v xcodegen >/dev/null 2>&1; then
            brew update
            brew install xcodegen
          fi
          xcodegen --version

      - name: üß© Generate Xcode project (Step 4)
        shell: bash
        run: |
          set -euo pipefail
          source ./cb.sh
          cb "{\"build_id\":\"$BUILD_ID\",\"step\":4,\"step_state\":\"active\",\"log\":\"iOS: üß© Generating Xcode project\"}"

          # Find project.yml
          PROJECT_YML="$(find work -name project.yml | head -n 1 || true)"
          if [ -z "$PROJECT_YML" ]; then
            echo "‚ùå project.yml not found"
            find work -maxdepth 4 -type f -print
            cb "{\"build_id\":\"$BUILD_ID\",\"step\":4,\"step_state\":\"failed\",\"log\":\"iOS: ‚ùå project.yml not found\",\"status\":\"failed\",\"error\":\"project.yml not found\"}"
            exit 1
          fi

          IOS_DIR="$(dirname "$PROJECT_YML")"
          echo "üìÇ IOS_DIR=$IOS_DIR"

          pushd "$IOS_DIR" >/dev/null
          xcodegen generate
          popd >/dev/null

          cb "{\"build_id\":\"$BUILD_ID\",\"step\":4,\"step_state\":\"done\",\"log\":\"iOS: ‚úÖ Xcode project generated\"}"

      - name: üìå Locate Xcode project + scheme
        shell: bash
        run: |
          set -euo pipefail
          source ./cb.sh

          XCODEPROJ="$(find work -name "*.xcodeproj" | head -n 1 || true)"
          if [ -z "$XCODEPROJ" ]; then
            echo "‚ùå No Xcode project found"
            find work -maxdepth 6 -type f -print
            cb "{\"build_id\":\"$BUILD_ID\",\"step\":4,\"step_state\":\"failed\",\"log\":\"iOS: ‚ùå No .xcodeproj found\",\"status\":\"failed\",\"error\":\"No Xcode project found\"}"
            exit 1
          fi
          echo "üì¶ XCODEPROJ=$XCODEPROJ"

          IOS_DIR="$(dirname "$XCODEPROJ")"
          echo "üìÇ IOS_DIR=$IOS_DIR"

          echo "üîç Listing schemes..."
          LIST_OUTPUT="$(xcodebuild -list -project "$XCODEPROJ" || true)"
          echo "$LIST_OUTPUT"

          # Robust scheme detection:
          # - get lines AFTER "Schemes:" and pick first non-empty trimmed line
          SCHEME="$(printf "%s\n" "$LIST_OUTPUT" | python3 - <<'PY'
import sys, re
txt=sys.stdin.read().splitlines()
in_schemes=False
schemes=[]
for line in txt:
    if re.match(r'^\s*Schemes:\s*$', line):
        in_schemes=True
        continue
    if in_schemes:
        if line.strip()=="":
            continue
        # scheme lines are indented names
        schemes.append(line.strip())
        # stop after first scheme to keep deterministic
        break
print(schemes[0] if schemes else "")
PY
)"
          if [ -z "$SCHEME" ]; then
            echo "‚ùå No scheme found"
            cb "{\"build_id\":\"$BUILD_ID\",\"step\":4,\"step_state\":\"failed\",\"log\":\"iOS: ‚ùå No scheme found\",\"status\":\"failed\",\"error\":\"No scheme found\"}"
            exit 1
          fi

          echo "üéØ SCHEME=$SCHEME"
          echo "IOS_DIR=$IOS_DIR" >> $GITHUB_ENV
          echo "XCODEPROJ=$XCODEPROJ" >> $GITHUB_ENV
          echo "SCHEME=$SCHEME" >> $GITHUB_ENV

      - name: üì± Queued on macOS Runner (Step 5)
        shell: bash
        run: |
          set -euo pipefail
          source ./cb.sh
          cb "{\"build_id\":\"$BUILD_ID\",\"step\":5,\"step_state\":\"active\",\"log\":\"iOS: üì± Queued on macOS runner\"}"
          cb "{\"build_id\":\"$BUILD_ID\",\"step\":5,\"step_state\":\"done\",\"log\":\"iOS: ‚úÖ Runner acquired\"}"

      - name: üî® Build with Xcode (Step 6)
        shell: bash
        run: |
          set -euo pipefail
          source ./cb.sh
          cb "{\"build_id\":\"$BUILD_ID\",\"step\":6,\"step_state\":\"active\",\"log\":\"iOS: üî® Building with Xcode\"}"

          pushd "$IOS_DIR" >/dev/null

          # Build (no signing) ‚Äî produces .app in DerivedData
          set +e
          xcodebuild \
            -project "$XCODEPROJ" \
            -scheme "$SCHEME" \
            -configuration Release \
            -destination 'generic/platform=iOS' \
            CODE_SIGNING_ALLOWED=NO \
            build | tee xcodebuild.log
          EXIT_CODE=${PIPESTATUS[0]}
          set -e

          popd >/dev/null

          if [ "$EXIT_CODE" -ne 0 ]; then
            echo "‚ùå xcodebuild failed with $EXIT_CODE"
            # Upload xcodebuild.log to GH artifacts too (nice for debugging)
            cb "{\"build_id\":\"$BUILD_ID\",\"step\":6,\"step_state\":\"failed\",\"log\":\"iOS: ‚ùå xcodebuild failed\",\"status\":\"failed\",\"error\":\"xcodebuild failed (exit $EXIT_CODE)\"}"
            exit 1
          fi

          cb "{\"build_id\":\"$BUILD_ID\",\"step\":6,\"step_state\":\"done\",\"log\":\"iOS: ‚úÖ Build succeeded\"}"

      - name: üì¶ Package iOS build artifact (Step 7)
        shell: bash
        run: |
          set -euo pipefail
          source ./cb.sh
          cb "{\"build_id\":\"$BUILD_ID\",\"step\":7,\"step_state\":\"active\",\"log\":\"iOS: üì¶ Packaging iOS build artifacts\"}"

          mkdir -p out

          # Collect useful outputs:
          # - xcodebuild.log
          # - generated project folder (so user can open)
          # - any .app built (if found)
          cp "$IOS_DIR/xcodebuild.log" out/xcodebuild.log || true

          # Try to find built .app
          APP_PATH="$(find ~/Library/Developer/Xcode/DerivedData -type d -name "*.app" | head -n 1 || true)"
          if [ -n "$APP_PATH" ]; then
            echo "‚úÖ Found app: $APP_PATH"
            ditto "$APP_PATH" "out/App.app"
          else
            echo "‚ö†Ô∏è No .app found in DerivedData (still packaging project + logs)"
          fi

          # Include the Xcode project directory
          ditto "$IOS_DIR" "out/Project"

          # Zip artifact
          ARTIFACT_ZIP="ios-${BUILD_ID}.zip"
          (cd out && zip -qr "../$ARTIFACT_ZIP" .)

          echo "ARTIFACT_ZIP=$ARTIFACT_ZIP" >> $GITHUB_ENV
          echo "ARTIFACT_KEY=ios/artifacts/${BUILD_ID}.zip" >> $GITHUB_ENV

          cb "{\"build_id\":\"$BUILD_ID\",\"step\":7,\"step_state\":\"done\",\"log\":\"iOS: ‚úÖ Artifact packaged\"}"

      - name: ‚òÅÔ∏è Upload artifact to iOS Worker R2
        shell: bash
        run: |
          set -euo pipefail
          source ./cb.sh

          # Upload via Worker (PUT to R2 not possible directly from Actions without keys)
          # We upload by POSTing to a Worker route that stores it in R2.
          # BUT your Worker currently supports: /artifact-ios/:id (GET) and stores via R2 in callback.
          # So: we base64 the zip and send to callback as artifact_blob_b64 (Worker will store).
          echo "Uploading artifact via callback‚Ä¶"

          B64="$(python3 - <<PY
import base64
data=open("${ARTIFACT_ZIP}","rb").read()
print(base64.b64encode(data).decode("ascii"))
PY
)"

          cb "{\"build_id\":\"$BUILD_ID\",\"log\":\"iOS: ‚òÅÔ∏è Uploading artifact to Worker R2\",\"level\":\"info\"}"

          # NOTE: Worker must implement saving artifact_blob_b64 to R2 at ios/artifacts/{buildId}.zip
          cb "{\"build_id\":\"$BUILD_ID\",\"status\":\"success\",\"artifact_key\":\"$ARTIFACT_KEY\",\"artifact_blob_b64\":\"$B64\",\"log\":\"iOS: ‚úÖ Uploaded artifact\"}"

      - name: ‚úÖ Complete (Step 8) ‚Äî terminal callback
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          source ./cb.sh

          # If previous steps failed, send failed terminal callback
          if [ "${{ job.status }}" != "success" ]; then
            cb "{\"build_id\":\"$BUILD_ID\",\"status\":\"failed\",\"log\":\"iOS: ‚ùå Build failed in GitHub Actions\",\"level\":\"error\"}" || true
            exit 0
          fi

          cb "{\"build_id\":\"$BUILD_ID\",\"step\":8,\"step_state\":\"done\",\"log\":\"iOS: ‚úÖ Complete\",\"status\":\"success\"}"
